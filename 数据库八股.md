# 索引

### 什么是索引？

索引是用来加快数据查找的数据结构，对一个或多个列进行预排序。一个数据（Entry）包含列的值和这条记录的引用。

### 索引的分类

聚类索引

索引顺序和表中数据的实际物理顺序相同

非聚类索引

### B+tree和B tree区别

B+Tree中间节点只存key值，对record的索引全部在叶子节点。

1. IO次数少。中间节点不存索引，就可以存更多key值，使tree高度更小，查询需要的node数量变少了。磁盘IO次数少了。
2. 范围查询更快，只需要遍历叶子节点

# 事务

把一系列操作作为一个整体看待，称之为一个事务

### ACID：

Atomic原子性：把所有操作作为一个工作单元，要么全部成功要么全部失败。

Consistency：一致性：事务必须使数据库从一个一致性状态，变到另一个一致性状态。

Isolation：隔离性：一个事务所做的修改在提交前对其他事务是不可见的。

Durability：持久性：事务一旦提交成功，对数据的修改是永久性的。即使数据库故障也不能变。

### 隔离级别

Read Uncommitted（未提交读）：导致脏读，即一个事务修改后还没提交的内容被另一个事务读到

Read Commited (提交读)： 避免脏读，导致不可重复读：事务修改数据前后读到不一样的值

Repeatable Read（可重复读）：避免不可重复读问题，导致幻读：新插入的记录在事务前后可以被另一个事务读到

Serializable（可串行化）：避免所有问题，但效率很低

# [数据库三大范式](https://www.cnblogs.com/lixingleon/p/15468833.html)

# 1NF

所有属性不可再分。满足1NF是关系型数据表的前提。不满足1NF就不是关系型数据表。

# 2NF

非主属性完全依赖于主属性。
**若非主属性仅部分依赖于主属性，则不符合第二范式。**
举例：学号，课程号，学分，成绩 四个字段组成一张表格，（学号，课程号）构成主键。

- 所有属性不能再分，满足第一范式。
- 但学分仅依赖于课程号，不依赖于学号。所以不满足第二范式。

应该改成：学号，课程号，成绩为一张表。课程号，学分为另一张表。

**不满足第二范式会导致四大问题：**

1. 数据冗余。所有元组都需要学分字段，会重复很多遍。
2. 更新异常。更新学分时，需要把所有元组的值都更新一遍。
3. 插入异常。还没学生选过的课没法插入。因为学号作为主键不能为空。
4. 删除异常。删除所有学生成绩会导致课程和学分也被删除。

# 3NF

不存在传递依赖关系，即非主属性之间没有依赖关系。
**若非主属性传递依赖于主属性，则不符合第三范式**
举例：学号，专业，专业描述 三个字段组成一张表格，学号是主键。

- 所有属性不能再分，满足第一范式。
- 学号是唯一主键，不存在部分依赖关系，满足第二范式。
- 学号决定专业，专业决定专业描述。所以存在传递依赖关系。不满足第三范式。

应该改成： 学号，专业为一张表。专业，专业描述为另一张表。
**不满足第三范式也会导致两大问题：**

1. 数据冗余。
2. 更新异常。

一般表的设计满足3NF就够了。

# 数据库的并发场景和解决方案

1. 事务A在增删改时，事务B也进行增删改
   1. 解决办法：不需要解决。InnoDB自动为增删改的事务添加排他锁，事务B会阻塞直到锁释放，所以无需在代码中做修改。
2. 事务A在查询时，事务B进行增删改
   1. 解决办法：不需要解决。RepeatableRead的隔离级别保证事务A不会读到事务B修改的数据。
3. 事务A先查，再更新同一张表。事务B也先查，再更新同一张表。B比A先提交，那A的更新就丢失了。
   1. 解决办法：给A的查询语句添加排他锁。(此处不能加共享锁，否则会造成死锁)

# 加锁原则

拿MySql的InnoDB引擎来说，对于`insert`、`update`、`delete`等操作。会自动给涉及的数据加排他锁；

对于一般的`select`语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。

共享锁：`SELECT ... LOCK IN SHARE MODE;`

排他锁：`SELECT ... FOR UPDATE;`

# MVCC在MySQL的InnoDB中的实现

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：

- SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
- INSERT时，保存当前事务版本号为行的创建版本号
- DELETE时，保存当前事务版本号为行的删除版本号
- UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

MVCC解决了快照读的不可重复读和幻读的问题。

对于当前读，仍然会有幻读问题。通过Next-key Lock 解决:

如果id列上有唯一索引：会加行锁

如果id列上是非唯一索引：加Gap锁

如果id列上没有索引：直接锁住整张表

