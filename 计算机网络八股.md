# TCP

### 什么是TCP？

TCP是面向连接的，可靠的，基于字节流的传输层协议

字节流：应用层传来的数据不知道是什么，只是当作字节来处理。

一对一：一个发送方只能将消息发给1个接收方，不能同时发给多个接收方。

头部至少20个字节，4个字节一行，一共5行

源端口 | 目的端口

序号

确认号

首部长度4bits | 保留| SYN，FIN，RST，ACK| 窗口

窗口



### TCP如何保证传输可靠？

1. TCP如何保证传输可靠性。

   首先，一个连接可能会有哪些问题：

   1. 数据包乱序且重复
   2. 丢包

   针对乱序且重复，如何解决：

   1. 发送时给每个packet都带上序列号（这个序列号是TCP三次握手时双方同步好的）

   针对丢包，如何解决：

   1. 丢包后重传。如何判断已经丢包？

   2. 1. 应答机制（延时ACK）收到请求后要发送确认报文，如果发送端在RTO时间内没收到确认报文，就认为已丢包
      2. 快重传机制，当连续收到3个相同的ACK，就认为已丢包，就快速重传。

   3. 流量控制：控制发送端的流量，使接收端的缓存不溢出。

   4. 1. 在应答报文的窗口字段里写明请求端可以同时发送的包数量

   5. 拥塞控制：控制发送端的流量，使网络不出现拥塞。

   6. 1. 拥塞窗口：同时可以发送的数据包数量。
      2. taho算法：慢启动（指数升高拥塞窗口），拥塞避免（线性升高拥塞窗口），快重传（收到三次相同ack后快速重传，且阈值变为当前窗口值得一半，窗口值直接降为1）。
      3. reno算法：快恢复（阈值变为当前拥塞窗口的一半，拥塞窗口也降低一半）。

### 三次握手建立连接

是为了交换一些TCP报文段。使客户端和服务端都得到必要的参数来进行后续的数据收发。其中最重要的是序号字段和确认号字段（ACK号）

TCP报文段是哪些呢？

控制位：

1. ACK用于指示确认字段中的值是有效的。即该报文段包含一个对已被成功接收的报文段的确认。

2. RST，SYN，FIN用于连接建立和拆除

![image-20211029134035757](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20211029134035757.png)

### 

![image-20211108112420105](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20211108112420105.png)

1. 客户端发送SYN报文
   - 首先，服务器进入Listen状态，主动监听某个端口。客户端向服务端发送一个不带应用层数据的TCP报文段，有两个重要参数，第一是SYN置为1， 第二是初始化一个序号字段（client_number）。SYN是synchronize的意思，所以这一步原理上就是把序号字段告知客户端，来使通信双方保持步调一致。之后客户端处于SYN-SENT状态
2. 服务端发送SYN-ACK报文
   - 服务端收到SYN报文后，将ACK，SYN置为1，将客户端序号client_number+1后填入ACK号，并生成一个自己的序号（server_number）填在序号字段，发送给客户端，这个报文也不包含应用层数据。ACK号置1就表明这个报文包含了对一个已被成功接收的报文的确认信息，确认号字段是有效的。之后进入SYN-RCVD状态
3. 客户端发送ACK报文
   - 客户端收到SYN-ACK报文后，将ACK置为1，ACK号填入server_number+1, 可能携带应用层数据，发送给服务端。发送后自己进入ESTABLISHED状态。服务端接收到ACK报文后，也进入ESTABLISHED状态。最后双方都拥有了对方的序号字段，连接成功。
   - 为什么第三次握手可以传输数据：
     1. 第三次ack发出时客户端已经是established状态了，对它来说连接已经完成了
     2. 客户端已经收到了服务端的序号字段并确定服务端知道自己的序号字段（第二次握手接收到确认字段）。

### 为什么不是2次和4次握手？

1. 避免历史请求初始化连接。

   - 客户端发了第一个SYN报文后迟迟未收到回应，又发了一个，结果先发的这时候到达服务端，服务端回送一个SYN-ACK报文。这时候如果是2次握手的话就建立连接了。但客户端接收到的却是已经过期的第一次的序号字段。所以历史请求初始化了连接，造成了混乱。

     这时候如果是三次握手的话，客户端收到旧的序号字段，会回送一个RST报文终止连接。只有收到新的序号字段时才会发送ACK报文，双方成功建立连接。

2. 确定双方都收到了彼此的序号字段。
   - 如果是两次握手，服务端不能得知客户端是否收到了自己的序号字段。客户端需要通过第三次握手告知客户端。
   - 序号字段的作用：
     1. 接收方可以按序接收，去除重复数据
     2. 发送方可以根据ack号确认哪些数据已被接收成功

3. 避免建立无效连接造成资源浪费
   - 客户端发送第一个报文后未收到回应，又发送一个，双方通过新的序号建立连接并完成通信，连接释放后，老的报文到了。这时候服务端发送确认报文，又进入连接状态。但客户端并没有连接需求，所以资源就浪费了。

建立连接后客户端故障：

1. 每次接收到客户端请求都会复位一个计时器，时间2h，超过2h以后，发送探测报文段，每隔75秒发送一个，如果发了10个都没收到回复，则关闭连接。

### SYN Flood攻击

服务器在第二次挥手后进入SYN-RCVD状态，此时会将连接放入半连接队列。如果黑客发送大量SYN报文，服务端的半连接队列被塞满就无法处理正常请求了。

### 4次挥手

客户端和服务端都可以发起断开连接请求。

![image-20211108150740921](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20211108150740921.png)

1. 客户端发送FIN报文：将FIN置为1， 发送后进入FIN-WAIT-1状态
2. 服务端收到FIN报文后，发送ACK应答报文，发送后进入CLOSED-WAIT状态，客户端收到ACK报文后，进入FIN-WAIT-2状态
3. 服务端处理完数据后，发送FIN报文：将FIN置为1，之后服务端进入LAST-ACK状态
4. 客户端收到FIN报文后，发送ACK应答报文，之后进入TIME-WAIT状态。服务端收到ACK后，进入CLOSE状态。至此服务端关闭成功。客户端经过2MSL(Maximum Segment Lifetime)时间后，也进入CLOSE状态，客户端关闭成功。

### 为什么挥手需要四次

客户端发送FIN报文表示不再发送数据了，但还能接收数据。服务端收到FIN报文后，先回复ACK报文表示知道要关闭了。但要把没发完的数据都发完后，再发送FIN报文。

### TIME-WAIT状态的意义

第四次挥手时，客户端发送的ACK有可能丢失。TIME-WAIT就是用来重发可能丢失的ACK报文。

如果服务端没有收到ACK，就会重新发送FIN，如果客户端在2MSL时间里收到了FIN，就重新发送ACK并再次等待2MSL，防止服务端没有收到ACK而一直重发FIN



### 建立连接后，数据收发阶段：

应用程序通过调用write方法将数据交给协议栈，但协议栈不会立即将数据发送，而是将其放在内部的发送缓冲区，并等待应用程序的下一条数据。

协议栈发送数据根据两个要素来判断：

1. 每个网络包能容纳的数据长度。
   1. MTU：maximum transmission unit :一个网络包最大长度
   2. MSS：maximum segment size：去掉头部后数据的最大长度
   3. 当数据积累到接近MSS后再发送，就能避免发送大量小包（带宽利用率不足）的问题
2. 时间。
   1. 当数据迟迟积累不够MSS，应果断发送。不能因为等待时间太长而影响用户体验。所以协议栈内部有一个计时器。

### TCP确认对方收到的原理：

TCP将数据看作一个无结构的，有序的字节流

1. 序号字段用来描述这个报文段第一个字节的字节流编号（在字节流中是第几个字节）

2. 接收方返回ACK号（根据序号和数据大小决定：ACK=序号+数据大小），表示该序号之前的数据我都已经收到了。
3. 数据大小怎么得到？接收方可以通过包大小减去头部大小等于数据大小的方式，得到这个包的数据量。

4. client收到ACK号，就能知道接收方收到了多少数据。

### 流量控制

避免发送方发送的数据大于接收方的缓存，导致数据溢出

tcp头部有一个窗口字段。表示无需确认等待就可一起发送的数据量。用于接收方给发送方发送指示：我还有多少剩余缓存空间。

![image-20211108160531223](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20211108160531223.png)

当接收窗口为0时？

发送方启动一个计时器，计时结束后发送探测数据包看接收方是否可以接收数据了。接收方会在返回报文中更新窗口大小

### 拥塞控制

避免发送方发送过多数据，导致网络拥塞。跟接收方无关。

慢开始算法，拥塞避免算法

1. 拥塞窗口初始值为1，慢开始算法指数增长拥塞窗口，到达阈值后切换成拥塞避免算法，线性增长拥塞窗口。
2. 当出现网络拥塞时，把拥塞窗口重新置1，并把切换算法的阈值设为之前的一半。

快重传快恢复算法

在接收端，每次收到报文都需要对最后一个已收到的报文进行确认。例如M3丢失了，M4收到后返回的是对M3的确认报文。

当连续收到三个重复确认时，知道此报文段丢失，执行快重传。

快恢复：将拥塞窗口值降为原来的一半，阈值等于降低后的拥塞窗口值。

![image-20211108173544154](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20211108173544154.png)

# UDP

1. TCP和UDP的区别：

   1. TCP是面向连接的，端到端的，可靠的字节流传输协议。

   2. UDP是不用建立连接，支持一对多，多对一，不可靠的。面向报文的。

   3. 1. 优点是头部数据少，传输数据效率更高。并且没有拥塞控制，即使出现网络阻塞，传输数据的速度不会降低。适合使用在实时性要求高的场景。

### 使用场景

DNS解析

音视频传输，游戏



# HTTP

HTTP是**应用层协议**。规定了客户端与服务端的通信方式和通信消息的格式。是**无状态协议**，服务端不保存客户端的信息。



### HTTP和HTTPS有什么区别

HTTP是明文传输的，HTTPS在HTTP的基础上使用SSL加密，更安全。

HTTP默认端口号80，HTTPS是443

HTTP响应速度快，HTTPS消耗资源多，响应速度慢，需要验证CA证书，并且加密数据。

### HTTPS传输过程

1. 客户端和服务端通过443端口建立TCP连接
2. 客户端发送支持的加密算法，SSL版本号，随机数等信息
3. 服务端选取合适的加密算法和SSL版本，发送自己的公钥和CA证书
4. 客户端收到后，验证CA证书是否受信任，是否过期，CA公钥能否解密证书上的数字签名。完成验证后，客户端生成对称密钥，并用服务端公钥加密后，发送给服务端
5. 服务端收到加密后的对称密钥，用自己的私钥解密。至此双方都拥有对称密钥了。
6. 双方再发送一条表示握手结束的通知消息，用对称密钥加密。如果双方验证加密解密都没问题。HTTPS传输就正式建立成功了。

### CA证书颁发过程

1. CA机构会把持有者的公钥，证书用途，颁发者，有效期等信息打包，生成一个hash值。并用自己的私钥加密哈希值，生成数字签名。打包的信息和数字签名就构成了CA证书
2. 客户端将证书上打包的信息也用同样的方式生成一个哈希值。并且用CA公钥解密数字签名。比较两者的值是否相等。若相等则通过验证。


### 对称加密和非对称加密

对称加密：加密解密用的是同一个密钥，优点：速度快，常用于大量数据加密。

非对称加密：加密用公钥，解密用私钥或者反过来。优点：不用传输密钥。更安全。

### HTTP1.0，1.1，2.0的区别

HTTP1.1的优化：

1. 持续连接
   1. HTTP1.0时，执行完一次请求和响应，连接就关闭了。HTTP1.1默认采用持久连接。建立连接后，可以进行多次请求和响应（设置connection的请求头为keep-alive）
2. 流水线（pipeline）操作
   1. HTTP1.1可以连续发送请求，不需要得到回应再发送。但是服务端需要按照顺序进行数据返回。处理过程是串行的，可能引起阻塞。
3. 增加host字段
   1. HTTP1.0默认一个IP地址只有一台服务器。HTTP1.1增加了host字段，这样一个服务器可以同时运行多个服务端程序。

HTTP2.0的优化：

1. 多路复用：
   1. 虽然1.1有pipeline操作，但处理是串行的，依旧会造成阻塞。2.0中响应和请求可以并行发送。因为2.0中响应和请求都是二进制传输的，用流来表示，而流又由帧组成，每个帧会有标识字段表明自己属于哪个流，所以不需要再串行发送信息了。
2. 头信息压缩
   1. 重复的头信息保存成字典，只传输索引。
3. 推送功能
   1. 服务器可以主动向客户端发送消息。比如浏览器请求HTML时，会主动把相应的CSS和JS文件推送给客户端。

### 从输入网址到获得页面的过程

1. 查询DNS获取域名对应的ip地址。
   1. 过程包括查浏览器的DNS缓存，读取本地host文件，查路由器缓存，查本地DNS服务器。如果本地DNS服务器也没有，就通过迭代查询的方式，向根服务器发出请求。
   2. 迭代查询：本地DNS服务器向根服务器发出请求。根服务器没有IP，将下一级服务器的IP返回给本地DNS服务器。本地DNS服务器再向下一级服务器发送请求。
   3. 递归查询：客户端向本地DNS服务器发送请求。本地DNS服务器没有对应IP地址，就会代客户端向根服务器查询。查到内容之后，再将IP返回给客户端。

2. 和服务端通过三次握手建立TCP连接

3. 发送HTTP请求，HTTP请求报文经过传输层加上TCP头，经过网络层加上IP头，经过数据链路层加上MAC头，然后传输至服务器

4. 服务器收到请求后，返回响应信息，包含URI对应的资源
5. 如果connection设置为close，则服务端发起四次挥手，关闭连接。

6. 浏览器解析并渲染页面。如果有图片等静态资源，会再次发送请求。
7. 浏览器根据所有收到的数据，最终渲染完成页面。

### GET与POST请求区别

1. GET一般用于获取服务器的资源，POST一般用于更新服务器资源，当客户端向服务端传输的数据较多时就用POST，比如表单提交。

2. GET请求的数据会附加在URL之后，用一个？开始，编码格式限制为ASCII，数据大小被URL长度限制，且明文保存，不安全。

   POST请求的数据保存在消息体中，没有编码格式限制，没有数据大小限制，更安全。

### 报文格式和状态码

**请求消息**：

请求行：<方法><空格><URI><空格><HTTP版本>

请求头：<字段名>: <字段值>

​				<字段名>: <字段值>

​				<字段名>: <字段值>

​				<空行>

请求体：<数据>

**常见请求头：**

Accept：客户端可接受的相应内容类型

Host：请求的主机和端口号

connection：连接方式（close或keepalive）

Cookie：

content-type：请求体类型

content-length：请求体长度

**响应消息：**

状态行：<HTTP版本><空格><状态码><空格><响应短语>

消息头：<字段名>: <字段值>

​				<字段名>: <字段值>

​				<字段名>: <字段值>

​				<空行>

消息体：<数据>



**状态码**

1. 1xx状态码：要求请求者继续 100 Continue
2. 2xx状态码：操作成功。200 OK
3. 3xx状态码：重定向。301 永久重定向（搜索引擎会替换旧网址）；302暂时重定向（搜索引擎会保留旧网址）
4. 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized（客户端可以携带验证消息再次请求）；403 Forbidden（客户端的请求被拒绝，不应该再次发送请求）；404 Not Found；
5. 5xx状态码：服务端错误。500服务器内部错误；501服务不可用

301：永久重定向。原地址的资源已经被永久移到了新地址，并且将来对该资源的引用都应该使用本响应返回的URI之一。客户端下次请求该资源最好用新的URI

302：临时重定向。客户端下次请求该资源还应该用老的URI

### 请求方法

GET： 

POST：提交表单或者上传文件。数据在请求体中。

HEAD：用于获取报头

PUT：修改

PATCH：增加

### session和cookie

1. cookie保存在客户端，session保存在服务端。cookie安全性要更差。cookie保存的数据量要更小，且一个站点一般最多保存20个cookie。
2. session的实现一般也是依靠cookie的，在cookie中存储sessionid。购物车是session的一个应用。如果用户禁用了cookie。sessionid会重写在url里





# OSI七层网络模型

每一层介绍：什么用途，有什么主要协议。

## 应用层

HTTP协议：web浏览器

FTP协议：文件传输

SMTP协议：邮件

DNS协议：DNS寻址

查询DNS获取域名对应的IP地址。

1. 过程包括查浏览器的DNS缓存，读取本地host文件，查路由器缓存，查本地DNS服务器。如果本地DNS服务器也没有，就通过迭代查询的方式，向根服务器发出请求。
2. 迭代查询：本地DNS服务器向根服务器发出请求。根服务器没有IP，将下一级服务器的IP返回给本地DNS服务器。本地DNS服务器再向下一级服务器发送请求。
3. 递归查询：客户端向本地DNS服务器发送请求。本地DNS服务器没有对应IP地址，就会代客户端向根服务器查询。查到内容之后，再将IP返回给客户端。

## 表示层

SSL协议。表示层和会话层在实际实现中一般都在应用层中实现。

## 会话层

## 传输层

TCP协议 UDP协议。解决了传输质量问题。

## 网络层

IP协议。路由器在这一层。

从A点到B点可能有很多数据链路。网络层决定其中最佳的一条路径

主要负责寻址。

## 数据链路层

交换机在这一层 MAC地址

将比特流组成帧，传输帧

## 物理层

传输比特流

