# Redis

缓存使用场景：

1. 对热点数据进行缓存减少DB压力。
2. 对依赖的服务缓存，提高并发性能。

### 1. 丰富的数据类型

五大数据结构

#####string:

用得最多，用来存储序列化后的对象

#####set：

给博客点赞功能：

key是博客id，value是用户id的set

#####sortedset：

点赞排行榜功能：

key是博客id，value是用户id和点赞时间的set

##### list：

双向链表

##### hash：

可以存对象，但属性不能嵌套，用得不多

### 2. 支持数据持久化

如果断电了，redis的数据就都消失了吗？

rdb (redis database):基于快照：依据配置规则**新开一个线程**保存快照——rdb文件，保存在bin目录里。

aof (append only file)：基于时间：可以每秒同步一次，实时性更好。

### 3. 一致性问题

缓存与数据库的数据不一致。

采用Cache Aside Pattern，旁路缓存模式。先更新数据库，再删除缓存。

### 4. 支持集群模式

主从复制的作用：

1. 读写分离，提高并发量
2. 故障恢复，避免单点故障

MySQL的主从复制依赖binlog，Redis的主从复制依赖RDB



### Redis为什么快？

1. 数据存储在内存，内存的读写比磁盘快很多
2. 数据结构的操作基本都是O(1)
3. 是单线程运作，没有上下文切换。并且通过IO多路复用机制，避免了IO阻塞。

### 为什么Redis只用单线程？

因为CPU不是redis性能的瓶颈，机器内存和网络带宽才是瓶颈。

### IO多路复用机制

先看下redis的事件处理模型，分四个部分：

1. 多个socket
2. IO多路复用程序
3. 文件事件派发器
4. 事件处理器

redis采用的是Reactor结构，是事件驱动型。可以同时监听多个来自客户端的连接。当被监听的socket准备好执行accept，read，write等操作时，会生成一个事件，塞到队列里。文件事件派发器将队列里的事件交给对应的处理器处理。

Redis在4.0版本之后给大数据量的删除操作增加了多线程的特性。

在6.0版本给网络IO增加了多线程特性，但是事件执行还是单线程的。

### Redis的删除策略和内存淘汰机制

1. 删除策略：惰性删除+定期删除
2. 淘汰机制：LRU（least recently used）

### 缓存穿透

大量请求数据库中不存在的key，导致请求穿过缓存，都落到数据库。

解决方案：

1. 做好参数校验
2. 缓存无效key，并设置短暂的过期时间
3. 布隆过滤器

### 缓存雪崩

1. Redis服务突然不可用
2. 或者热点缓存在某一时刻集体过期

针对情况1，解决方案是采用Redis集群

针对情况2，解决方案是给热点数据设置不同的失效时间，或者缓存永不失效。

还可以将sync设置为true，即加锁。表示开启同步查询，这样对于相同key的大量请求，只会有一个去数据源去查，其他请求会被挡在Redis层。

### 分布式锁

借用lua脚本来实现原子化操作

