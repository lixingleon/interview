# 索引

### 什么是索引？

索引是用来加快数据查找的数据结构，一个数据（Entry）包含创建索引的这个列的值和这条记录的引用（这条记录所在的数据页的引用）。

### 索引的分类

聚集索引

索引结构和数据在一起存放的索引。主键索引就是聚集索引

非聚集索引

索引结构和数据分开存放的索引。辅助索引都是非聚集索引

辅助索引包含：唯一索引，普通索引等

### 索引失效场景

1. or前后有字段没加索引
2. like以%开头
3. 联合索引违反最左匹配原则：
   1. 使用顺序必须是从左到右，中途有索引没用到（或使用范围查询），则之后的索引都不会被用到。

### B+tree和B tree区别

B+Tree中间节点只存key值，对record的索引全部在叶子节点。

1. IO次数少。中间节点不存索引，就可以存更多key值，使tree高度更小，查询需要的node数量变少了。磁盘IO次数少了。
2. 范围查询更快，只需要遍历叶子节点
3. 查询效率更稳定



# MyISAM和InnoDB引擎的区别：

MyISAM只支持表锁，不支持事务，崩溃后不能恢复

MyISAM的主键索引存放的是数据是指针，InnoDB存放的直接是数据。

主键之所以要尽可能小，且单调。是因为辅助索引都要存放主索引，这样占的空间尽可能小。且如果主键不单调，B+树需要频繁调整。



# 事务

关系型数据库的特点：支持事务

把一系列操作作为一个整体看待，称之为一个事务

### ACID特性

Atomic原子性：把所有操作作为一个工作单元，要么全部成功要么全部失败。

Consistency：一致性：事务必须使数据库从一个一致性状态，变到另一个一致性状态。

Isolation：隔离性：一个事务所做的修改在提交前对其他事务是不可见的。

Durability：持久性：事务一旦提交成功，对数据的修改是永久性的。即使数据库故障也不能变。

MySQL通过undo log保证原子性，redo log保证持久性，MVCC和锁机制保证隔离性，保证了这三个特性才能保证一致性。

### 隔离级别

Read Uncommitted（未提交读）：导致脏读，即一个事务修改后还没提交的内容被另一个事务读到

Read Commited (提交读)： 避免脏读，导致不可重复读：事务修改数据前后读到不一样的值

Repeatable Read（可重复读）：避免不可重复读问题，导致幻读：新插入的记录在事务前后可以被另一个事务读到

Serializable（可串行化）：避免所有问题，但效率很低



# 数据存储和读写单位

页是数据库的最小磁盘单位，默认大小是16KB，每次至少读写一页。

# 数据库结构

server层+存储引擎层

存储引擎层有buffer pool 做缓存。需要读写的数据页如果在buffer pool中，就直接读写。

如果写操作需要的数据页不在buffer pool中，就将操作写在change buffer中，减少insert和update操作带来的磁盘IO。等读到这个数据页，再将change buffer中的写操作执行，然后返回。（但对于唯一索引的操作，还是会先读再写）

# 三大日志

redo log

记录普通数据页的改动和changebuffer的改动。

在事务执行过程中就写入，先写到redo log buffer，再刷盘到redo log日志中。redo log是物理日志，记录在某个数据页做了什么操作。

bin log

在事务执行过程中写入binlog cache，在事务commit以后写入binlog 日志。

如果事务执行到中途发生异常，redolog已经写入了，binlog还没写入，这时binlog和redolog可能会不一致。解决方案是：将redolog的写入拆分成两阶段，先是prepare阶段，binlog写入后变成commit阶段。

undo log

用于数据回滚，保证原子性。

# 锁机制

拿MySql的InnoDB引擎来说，对于`insert`、`update`、`delete`等操作。会自动给涉及的数据加排他锁；

对于一般的`select`语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。

共享锁：`SELECT ... LOCK IN SHARE MODE;`

排他锁：`SELECT ... FOR UPDATE;`

表锁 行锁

乐观锁

认为修改冲突很少会发生。通过CAS或者版本号实现

悲观锁

认为修改冲突经常会发生。通过加锁实现

# MVCC

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：

- SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
- INSERT时，保存当前事务版本号为行的创建版本号
- DELETE时，保存当前事务版本号为行的删除版本号
- UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

MVCC解决了快照读的不可重复读和幻读的问题。

对于当前读，仍然会有不可重复读和幻读问题。通过Next-key Lock 解决:

如果id列上有唯一索引：会加行锁

如果id列上是非唯一索引：加Gap锁

如果id列上没有索引：直接锁住整张表





# [数据库三大范式](https://www.cnblogs.com/lixingleon/p/15468833.html)

# 1NF

所有属性不可再分。满足1NF是关系型数据表的前提。不满足1NF就不是关系型数据表。

# 2NF

非主属性完全依赖于主属性。
**若非主属性仅部分依赖于主属性，则不符合第二范式。**
举例：学号，课程号，学分，成绩 四个字段组成一张表格，（学号，课程号）构成主键。

- 所有属性不能再分，满足第一范式。
- 但学分仅依赖于课程号，不依赖于学号。所以不满足第二范式。

应该改成：学号，课程号，成绩为一张表。课程号，学分为另一张表。

**不满足第二范式会导致四大问题：**

1. 数据冗余。所有元组都需要学分字段，会重复很多遍。
2. 更新异常。更新学分时，需要把所有元组的值都更新一遍。
3. 插入异常。还没学生选过的课没法插入。因为学号作为主键不能为空。
4. 删除异常。删除所有学生成绩会导致课程和学分也被删除。

# 3NF

不存在传递依赖关系，即非主属性之间没有依赖关系。
**若非主属性传递依赖于主属性，则不符合第三范式**
举例：学号，专业，专业描述 三个字段组成一张表格，学号是主键。

- 所有属性不能再分，满足第一范式。
- 学号是唯一主键，不存在部分依赖关系，满足第二范式。
- 学号决定专业，专业决定专业描述。所以存在传递依赖关系。不满足第三范式。

应该改成： 学号，专业为一张表。专业，专业描述为另一张表。
**不满足第三范式也会导致两大问题：**

1. 数据冗余。
2. 更新异常。

一般表的设计满足3NF就够了。